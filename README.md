# DPsolver
## Authors
2003:
Kevin Sadvari

## About
The included Makefile contains rules for 'silent', 'verbose', and 'all'.  These will create the executables dpsilent and dpverbose, differing only in whether or not output is generated by the solvers.  For either one, usage is as follows:
	./<executable> <inputfile> <# of iterations>
as in:
	./dpsilent testfile 10000
This will run each solver on the problem given in testfile the given number of times, and print the total time used, and the last answer given, and will also give the time used by just parsing the problem n times for comparison purposes.  For relatively simple problems, about 1000 - 10000 iterations are needed to get meaningful time results.

Input file format:
Each statement is given on a separate line.  No whitespace is permitted, and the file must end with the newline that ends the last statement.  Statements are given in prefix notation.  Parentheses are used only as required, extraneous parentheses are not permitted.
Atomic statements are given as capital letters, and their negations by preceding the letter with '!', as A and !A.
The binary operators are & (and), | (or), > (conditional).  They are used as follows:
<op>(<left operand>),(<right operand)
as &(A),(>(B),(C)) for A^(B->C).
The only unary operator is ! for not.  This is used as "!(...)".  While !(A) and !A have the same truth-functional meaning, !(A) uses a more complex representation, and so the !A form is recommended.  

Understanding the output:
At each step, the solver will show the state of the branch under consideration, and the literal it is branching on.  For generalized DP, the state is given by the contents of the statement trees.  In each tree, element 0 is the root node, and the left and right operands of any operator node i are in 2*i+1 and 2*i+2.  The operators used are:
     -5    left
     -4    right
     -3    &
     -2    |
     0     null
     2     ->
     3     !left
     4     !right
     >=6   literal
     <=-6  !literal

The output given by the standard DP solver is much simpler, just showing the contents of each clause in the branch being considered.

BUGS:
The parser does no error checking, so using a malformed input file will generate a seg. fault.  The parser could probably be made significantly more efficient, as well, but, since it is used equally by both methods, this does not affect any efficiency comparisons.
More, or clearer, output would probably be useful.
